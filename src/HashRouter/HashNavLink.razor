@using Microsoft.AspNetCore.Components
@inject HashNavigationManager NavigationManager
@implements IDisposable

<a href="@ComputedHref" class="@ComputedClass" @attributes="AdditionalAttributes"   @onclick="OnClick"
       @onclick:preventDefault>
    @ChildContent
</a>

@code {
    /// <summary>
    /// The hash path to navigate to (without the # prefix).
    /// </summary>
    [Parameter]
    public string? Href { get; set; }

    /// <summary>
    /// CSS class(es) to apply to the link element.
    /// </summary>
    [Parameter]
    public string? Class { get; set; }

    /// <summary>
    /// CSS class to apply when the link is active.
    /// </summary>
    [Parameter]
    public string ActiveClass { get; set; } = "active";

    /// <summary>
    /// How to determine if the link is active.
    /// </summary>
    [Parameter]
    public HashNavLinkMatch Match { get; set; } = HashNavLinkMatch.Prefix;

    /// <summary>
    /// Content to render inside the anchor element.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Additional HTML attributes to apply to the anchor element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public IDictionary<string, object>? AdditionalAttributes { get; set; }

    private string ComputedHref => "#" + (Href?.TrimStart('#') ?? "");

    private string ComputedClass
    {
        get
        {
            var classes = new List<string>();

            if (!string.IsNullOrEmpty(Class))
            {
                classes.Add(Class);
            }

            if (IsActive && !string.IsNullOrEmpty(ActiveClass))
            {
                classes.Add(ActiveClass);
            }

            return string.Join(" ", classes);
        }
    }

    private bool IsActive
    {
        get
        {
            var currentHash = NavigationManager.Hash;

            if (string.IsNullOrEmpty(Href))
                return string.IsNullOrEmpty(currentHash) || currentHash == "/";

            var targetPath = NormalizePath(Href);
            var currentPath = NormalizePath(currentHash);

            return Match switch
            {
                HashNavLinkMatch.All => string.Equals(targetPath, currentPath, StringComparison.OrdinalIgnoreCase),
                HashNavLinkMatch.Prefix => currentPath.StartsWith(targetPath, StringComparison.OrdinalIgnoreCase),
                _ => false
            };
        }
    }

    private static string NormalizePath(string path)
    {
        // Remove query string
        var queryIndex = path.IndexOf('?');
        if (queryIndex >= 0)
        {
            path = path.Substring(0, queryIndex);
        }

        // Normalize slashes
        path = path.Trim('#', '/');

        // Empty path represents root
        return string.IsNullOrEmpty(path) ? "/" : "/" + path;
    }

    protected override void OnInitialized()
    {
        NavigationManager.LocationChanged += OnLocationChanged;
    }

    private void OnLocationChanged(object? sender, HashLocationChangedEventArgs e)
    {
        StateHasChanged();
    }

    private void OnClick()
    {
        if (!string.IsNullOrEmpty(Href))
        {
            var hashPath = Href.TrimStart('#');
            NavigationManager.NavigateTo(hashPath);
        }
    }

    public void Dispose()
    {
        NavigationManager.LocationChanged -= OnLocationChanged;
    }
}